<?php

	/**
	 * @package core
	 */

	 /**
	  * The Configuration class acts as a property => value store for settings
	  * used throughout Symphony. The result of this class is a string containing
	  * a PHP representation of the properties (and their values) set by the Configuration.
	  * Symphony's configuration file is saved at `CONFIG`. The initial
	  * file is generated by the Symphony installer, and then subsequent use of Symphony
	  * loads in this file for each page view. Like minded properties can be grouped.
	  */
	Class Configuration{

		/**
		 * An associative array of the properties for this Configuration object
		 * @var array
		 */
		private $_properties = array();

		/**
		 * Whether all properties and group keys will be forced to be lowercase.
		 * By default this is false, which makes all properties case sensitive
		 * @var boolean
		 */
		private $_forceLowerCase = false;

		/**
		 * The constructor for the Configuration class takes one parameter,
		 * `$forceLowerCase` which will make all property and
		 * group names lowercase or not. By default they are left to the case
		 * the user provides
		 *
		 * @param boolean $forceLowerCase
		 *  False by default, if true this will make all property and group names
		 *  lowercase
		 */
		public function __construct($forceLowerCase=false){
			$this->_forceLowerCase = $forceLowerCase;
			$this->_migrateToXML();
			$this->read();
		}

		/**
		 * Setter for the `$this->_properties`. The properties array
		 * can be grouped to be an 'array' of an 'array' of properties. For instance
		 * a 'region' key may be an array of 'properties' (that is name/value), or it
		 * may be a 'value' itself.
		 *
		 * @param string $name
		 *  The name of the property to set, eg 'timezone'
		 * @param string $value
		 *  The value for the property to set, eg. '+10:00'
		 * @param string $group
		 *  The group for this property, eg. 'region'
		 */
		public function set($name, $value, $group = null){
			if($this->_forceLowerCase){
				$name = strtolower($name); $group = strtolower($group);
			}

			$value = stripslashes($value);

			if($group) {
				$this->_properties[$group][$name] = $value;
			}
			else {
				$this->_properties[$name] = $value;
			}
		}

		/**
		 * A quick way to set a large number of properties. Given an array that may
		 * contain 'property' => 'value' or 'group' => array('property' => 'value') or
		 * a combination of both, this will PHP's array_merge with `$this->_properties`
		 *
		 * @param array $array
		 *  An associative array of properties, 'property' => 'value' or 'group' => array(
		 *  'property' => 'value')
		 * @param boolean $overwrite
		 *  An optional boolean parameter to indicate if it is safe to use array_merge 
		 *  or if the provided array should be integrated using the 'set()' method 
		 *  to avoid possible change collision. Defaults to false.
		 */
		public function setArray(array $array, $overwrite = false){
			$array = General::array_map_recursive('stripslashes', $array);
			if($overwrite) {
				$this->_properties = array_merge($this->_properties, $array);
			} else {
				foreach($array as $set => $values) {
					foreach($values as $key => $val) {
						self::set($key, $val, $set);
					}
				}
			}
		}

		/**
		 * Accessor function for the `$this->_properties`. If the
		 * `$name` is provided, the resulting value will be run through
		 * PHP's stripslashes.
		 *
		 * @param string $name
		 *  The name of the property to retrieve
		 * @param string $group
		 *  The group that this property will be in
		 * @return array|string
		 *  If `$name` or `$group` are not
		 *  provided this function will return the full `$this->_properties`
		 *  array.
		 */
		public function get($name=null, $group=null){

			// Return the whole array if no name or index is requested
			if(!$name && !$group) return $this->_properties;

			if($this->_forceLowerCase){
				$name = strtolower($name); $group = strtolower($group);
			}

			if($group){
				return (isset($this->_properties[$group][$name]) ? $this->_properties[$group][$name] : null);
			}

			return (isset($this->_properties[$name]) ? $this->_properties[$name] : null);
		}
		
		/**
		 * The hasValue function checks if a configuration setting
		 * exists and whether it has value.
		 * 
		 * @param String $name The name of the setting
		 * @param String $group The name of the group the setting is part of (optional)
		 * @return boolean
		 */
		public function hasValue($name, $group=null) {
			if($group) {
				return (isset($this->_properties[$group][$name]) && !empty($this->_properties[$group][$name]));
			} else {
				return (isset($this->_properties[$name]) && !empty($this->_properties[$name]));
			}
		}

		/**
		 * The remove function will unset a property by `$name`.
		 * It is possible to remove an entire 'group' by passing the group
		 * name as the `$name`
		 *
		 * @param string $name
		 *  The name of the property to unset. This can also be the group name
		 * @param string $group
		 *  The group of the property to unset
		 */
		public function remove($name, $group = null) {
			if ($this->_forceLowerCase) {
				$name = strtolower($name); $group = strtolower($group);
			}

			if ($group && isset($this->_properties[$group][$name])) {
				unset($this->_properties[$group][$name]);
			}

			else if ($this->_properties[$name]) {
				unset($this->_properties[$name]);
			}
		}

		/**
		 * Empties all the Configuration values by setting `$this->_properties`
		 * to an empty array
		 */
		public function flush(){
			$this->_properties = array();
		}

		/**
		 * This magic `__toString` function converts the internal `$this->_properties`
		 * array into a string representation. Symphony generates the `MANIFEST/config.php`
		 * file in this manner. All values are run through PHP's `addslashes` prior to saving.
		 *
		 * @return string
		 *  A string that contains a array representation of `$this->_properties`.
		 *  This is used by Symphony to write the `config.php` file.
		 */
		public function __toString(){
			$string = '';
			foreach($this->_properties as $group => $data){
				$string .= str_repeat(PHP_EOL, 2) . "\t" . '<group name="'.$group.'">';
				foreach($data as $key => $value){
					$string .= PHP_EOL . "\t\t" . '<item name="'.$key.'">'.(strlen($value) > 0 ? addslashes($value) : '')."</item>";
				}
				$string .= PHP_EOL . "\t</group>";
			}
			return $string;
		}

		/**
		 * Function will load the Configuration settings into 
		 * the Properties array
		 * 
		 * @param string $file
		 *  The path of the config file to load
		 * @return boolean
		 */
		public function read($file = CONFIG, $override = false) {
			$xmlDoc = new DOMDocument();
			$xmlDoc->load($file);
			
			$xpath = new DOMXPath($xmlDoc);
			$xpath->registerNamespace('s','http://symphony-cms.com/2012/03/config');
			$groupNodes = $xpath->query('/s:configuration/s:group');
			
			foreach($groupNodes as $groupNode) {
				foreach($groupNode->childNodes as $itemNode) {
					if($itemNode->nodeType == XML_ELEMENT_NODE) {
						$group = $groupNode->hasAttribute('name') ? $groupNode->getAttribute('name') : null;
						$name = $itemNode->hasAttribute('name') ? $itemNode->getAttribute('name') : null;
						$value = $itemNode->textContent;
						
						if($name == null || $group == null) {
							//TODO: I'm not familiar with Error handling in the Symphony Core.
							//		As Configuration is a pretty important part of it, maybe this should get some attention.
							throw new Exception();
						} else {
							if(!$this->hasValue($name,$group) || $override) {
								$this->set($name,$value,$group);
							}
						}
					}
				}
			}

			// Import additional configuration files
			$importNodes = $xpath->query('/s:configuration/s:import');
			foreach($importNodes as $importNode) {
				if($importNode->nodeType == XML_ELEMENT_NODE) {
					$file = $importNode->hasAttribute('href') ? $importNode->getAttribute('href') : null;
					$override = $importNode->hasAttribute('override') ? $importNode->getAttribute('override') : false;
					$override = (strtolower($override) == 'true') ? true : false;
					
					// Ignore the import statement if the file does not exist, do not throw Exception!
					// This allows specific environment configuration by adding
					// an import for a file that only exists on that environment.
					if(file_exists(MANIFEST . '/' . $file)) {
						$this->read(MANIFEST . '/' . $file, $override);
					}
				}
			}
 		}
		
		/**
		 * Function will write the current Configuration object to
		 * a specified `$file` with the given `$permissions`.
		 *
		 * @param string $file
		 *  the path of the file to write.
		 * @param integer|null $permissions (optional)
		 *  the permissions as an octal number to set set on the resulting file.
		 *  If this is not provided it will use the permissions defined in [`write_mode`][`file`]
		 * @return boolean
		 */
		public function write($file = null, $permissions = null){
			if(is_null($permissions) && isset($this->_properties['write_mode']['file'])){
				$permissions = $this->_properties['write_mode']['file'];
			}

			if(is_null($file)) {
				$file = CONFIG;
			}

			$string = '<?xml version="1.0" encoding="UTF-8"?>' . "\n" . '<configuration xmlns="http://symphony-cms.com/2012/03/config">' . (string)$this . "\n\n</configuration>\n";

			return General::writeFile($file, $string, $permissions);
		}

		/**
		 * Migration Assistant for pre-XML based configuration
		 * This will load the config.php file and transform the settings to XML
		 * The method can be removed when backwards-compatibility with 2.2.x line is broken.
		 */
		private function _migrateToXML() {
			if(file_exists(MANIFEST . '/config.php')) {
				include(MANIFEST . '/config.php');
				foreach($settings as $group=>$items) {
					foreach ($items as $name=>$value) {
						$this->set($name,$value,$group);
					}
				}
				$this->write(MANIFEST . '/config.xml');
				
				# Migration is done, let's delete the old config file
				unlink(MANIFEST . '/config.php');
			}
		}
		
	}
